#!/usr/bin/env bash

# Shell prompt based on the Solarized Dark theme.
# Screenshot: http://i.imgur.com/EkEtphC.png
# Heavily inspired by @necolas’s prompt: https://github.com/necolas/dotfiles
# iTerm → Profiles → Text → use 13pt Monaco with 1.1 vertical spacing.

# Function to generate PS1.
export PROMPT_COMMAND=__prompt_command

# PS2 is the continuation prompt which is the promt given below the first line
# for multi-line commands.
if tput setaf 1 &>/dev/null; then
	tput sgr0 # reset colors
	reset=$(tput sgr0)
	green=$(tput setaf 64)
else
	reset="\e[0m"
	green="\e[1;32m"
fi

PS2="\[${green}\]→ \[${reset}\]"
export PS2

if [[ $COLORTERM == gnome-* && $TERM == xterm ]] && infocmp gnome-256color >/dev/null 2>&1; then
	export TERM='gnome-256color'
elif infocmp xterm-256color >/dev/null 2>&1; then
	export TERM='xterm-256color'
fi

function __prompt_command() {
	# We need to capture the exit code of the last command first, before we run any of the commands
	# below which will have their own exit codes.
	local last_exit="$?"

	local blue=""
	local bold=""
	local cyan=""
	local green=""
	local red=""
	local reset=""
	local white=""
	local yellow=""

	local hostStyle=""
	local hostPrompt=""
	local userStyle=""

	if tput setaf 1 &>/dev/null; then
		tput sgr0 # reset colors
		bold=$(tput bold)
		reset=$(tput sgr0)
		# Solarized colors, taken from http://git.io/solarized-colors.
		blue=$(tput setaf 33)
		cyan=$(tput setaf 37)
		green=$(tput setaf 64)
		red=$(tput setaf 124)
		violet=$(tput setaf 61)
		white=$(tput setaf 15)
		yellow=$(tput setaf 136)
	else
		bold=''
		reset="\e[0m"
		blue="\e[1;34m"
		cyan="\e[1;36m"
		green="\e[1;32m"
		red="\e[1;31m"
		violet="\e[1;35m"
		white="\e[1;37m"
		yellow="\e[1;33m"
	fi

	# Highlight the user name when logged in as root.
	if [[ "${USER}" == "root" ]]; then
		userStyle="${red}"
	else
		userStyle="${green}"
	fi

	# Display and highlight the hostname when connected via SSH.
	if [[ "${SSH_TTY}" ]]; then
		hostStyle="${bold}${cyan}"
		hostPrompt="\[${white}\]@\[${hostStyle}\]\h"
	fi

	# Set the terminal title and prompt.
	PS1="\[\033]0;\W\007\]"   # working directory base name
	PS1+="\[${bold}\]\n"      # newline
	PS1+="\[${userStyle}\]\u" # username
	PS1+="${hostPrompt}"      # host
	PS1+="\[${white}\]:"
	PS1+="\[${blue}\]\w"                                                      # working directory full path
	PS1+="\$(prompt_git \"\[${white}\] on \[${violet}\]\" \"\[${yellow}\]\")" # Git repository details

	PS1+=' $(kube_ps1)'

	PS1+="\n"

	# Color `$` based on status code of previous command, green if it was zero,
	# red if it was non-zero and then reset the color.
	# PS1+="\[${white}\]\$ \[${reset}\]"; # `$` (and reset color)
	if [ $last_exit != 0 ]; then
		PS1+="\[${red}\]\$ \[${reset}\]" # Add red if exit code non 0
	else
		PS1+="\[${green}\]\$ \[${reset}\]"
	fi

}

prompt_git() {
	local s=''
	local branchName=''

	# Check if the current directory is in a Git repository.
	if [ "$(
		git rev-parse --is-inside-work-tree &>/dev/null
		echo "${?}"
	)" == '0' ]; then

		# check if the current directory is in .git before running git checks
		if [ "$(git rev-parse --is-inside-git-dir 2>/dev/null)" == 'false' ]; then
			# Check if there have been any changes.
			if [ -n "$(git status --porcelain)" ]; then
				s+='dirty'
			fi
		fi

		# Get the short symbolic ref.
		# If HEAD isn’t a symbolic ref, get the short SHA for the latest commit
		# Otherwise, just give up.
		branchName="$(git symbolic-ref --quiet --short HEAD 2>/dev/null ||
			git rev-parse --short HEAD 2>/dev/null ||
			echo '(unknown)')"

		[ -n "${s}" ] && s=" (${s})"

		echo -e "${1}${branchName}${2}${s}"
	else
		return
	fi
}
